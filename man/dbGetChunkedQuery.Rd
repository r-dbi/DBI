% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/DBConnection.R
\docType{data}
\name{dbGetChunkedQuery}
\alias{dbBreak}
\alias{dbGetChunkedQuery}
\alias{dbGetChunkedQuery,DBIConnection,character-method}
\title{Fetch data in chunks and access it with a callback}
\usage{
dbGetChunkedQuery(conn, statement, callback, n = 10000L, ...)
}
\arguments{
\item{conn}{A \code{\linkS4class{DBIConnection}} object, as produced by
\code{\link{dbConnect}}.}

\item{statement}{A character vector of length 1 containing SQL.}

\item{callback}{A callback function whose signature must be:
\code{function(df, index)}, where \code{df} is be the (partial) result set
(expressed as a dataframe) returned by the \code{statement}, and
\code{index} is the cumulative number of rows fetched so far.}

\item{n}{The number of rows to fetch in each chunk.}

\item{...}{Other parameters passed on to methods.}
}
\value{
The last chunk of data fetched (invisibly).
}
\description{
This function allows you to fetch data in chunks of \code{n} rows at a time
and acess that chunk using a callback. This is meant as a safer and more
efficient alternative to \code{\link{dbSendQuery}}. On one hand, it does not
keep the result set open, so you don't have to worry about
\code{\link{dbClearResult}}. On the other hand, you never need to have all
of the data on your machine at once (each chunk comes and goes), but you can
still produce global results.
}
\details{
For most use cases, you will want to actually loop through all of the data.
But there are some cases for which this is not true (for example, if you
just want to locate a particular row). In these situations, you can stop the
function from continuing to execute once your terminating condition is met.
To do so, use: \code{if (terminatingCondition) return(dbBreak)}.
\code{dbBreak} is a sentinel value that \code{DBI} recognizes and knows how
to interpret correctly.
}
\examples{

con <- dbConnect(RSQLite::SQLite(), ":memory:")
dbWriteTable(con, "cars", cars)

## Want to loop through all chunks to produce a global result
distSum <- 0
rowCount <- 0

dbGetChunkedQuery(con, "SELECT dist FROM cars", function(df, index) {
  distSum <<- distSum + sum(df$dist)
  rowCount <<- rowCount + nrow(df)
}, n = 10)

(distAvg <- distSum / rowCount)

## Want to stop once we find the row we're looking for
rowCount <- 0

dbGetChunkedQuery(con, "SELECT * FROM cars", function(df, index) {
  rowCount <<- rowCount + nrow(df)
  if (df$speed == 19 && df$dist == 46) {
    print(paste("Your row is number", rowCount))
    FALSE
  }
}, n = 1)

dbDisconnect(con)
}
\seealso{
Other connection methods: \code{\link{dbDisconnect}},
\code{\link{dbExistsTable}}, \code{\link{dbGetException}},
\code{\link{dbGetQuery}}, \code{\link{dbListFields}},
\code{\link{dbListResults}}, \code{\link{dbListTables}},
\code{\link{dbReadTable}}, \code{\link{dbRemoveTable}},
\code{\link{dbSendQuery}}
}
\keyword{datasets}

